---
title: "We've gone too far into the frontend"
date: "2021-05-21"
author: "Pedro S Lopez"
pullQuote: "A lesson in API design and separation of concerns"
image: "weve-gone-too-far-into-the-frontend/210521-save-actions.png"
tags: [engineering, notes]
---

The rise in popularity of frontend libraries and frameworks like React, Vue and Angular make it easier than ever before to build rich and interactive web apps. Pair these powerful libraries with a nice API to pull some data, and you can pretty quickly build out complex use cases. However, the _ability_ to do so many things on the client side doesn't always mean you _should_.

As a tool for keeping important data synchronized between systems, Grouparoo's various React apps need to support some pretty complex flows. They're used to manage and configure what exactly happens when profiles are being synced, which has real effects on your data.

For example, in the page used to configure a given destination, you are asked to select which group of profiles the destination should track. This determines who gets synced to the destination and who does not.

<Image
  centered
  alt="Selecting the destination's tracked group"
  src="weve-gone-too-far-into-the-frontend/select-group.png"
  width={861}
  height={533}
/>

This may seem simple at first, but it means that doing a simple action like changing the group, a number of things need to happen. If the tracked group has changed, we may need to kick off a run to get the latest data for all the affected profiles and export them to the destination. Similarly, if the destination is no longer tracking a group, we need to go to the destination and remove all the profiles that had been sent over in previous exports.

To support this, our API had exposed three endpoints:

- One for updating the destination's data, setting options and configuring which properties would be sent over.
- Another for setting the newly-tracked group and kicking off an import/export of profiles, if needed.
- Another for removing the previously-tracked group from the destination and kicking off an export to remove the profiles for the destination, if needed.

Our simple button at the bottom of the page to save destination data now had to determine if the group had been changed and execute a number of API requests.

<Image
  centered
  alt="Save button calling many actions"
  src="weve-gone-too-far-into-the-frontend/210521-save-actions.png"
  width={1015}
  height={533}
/>

## What could possibly go wrong?

Our nice API that could support so many use cases and our smart frontend that could decide what things to do now led to executing multiple, sequential API requests from a single button click. At first glance this may not seem so bad; we're bringing more flexibility to how the API can be used. However, the devil is in the details.

**⏳ Network speeds**

A somewhat obvious issue with having to do more requests is that you end up having to do multiple roundtrips to the server. If the client has a spotty connection, this could lead to longer response times and increases the amount of things that can go wrong.

**❌ Partial failures**

Something could always go wrong when issuing any of those requests. If your first request fails, then maybe everything's fine. But what if the first one succeeds but the second one doesn't? Do we need to rollback the first one? What if _that_ fails? Nasty.

**↔️ State changes between requests**

Another problem that comes with issuing multiple requests is that there's no guarantee that the state will be the same when that second request arrives to the backend. What if another user issued a request to update the same resource and it happened to be processed before yours? The state of that resource could be different at this point, meaning that your second request could produce unintended results.

A very similar issue was happening at Grouparoo, where the group that the client _thought_ the destination was tracking was actually some other group. This meant that we could potentially miss triggering an export in certain scenarios.

## The frontend is doing too much

So how do we solve this problem? Ultimately, the solution lies in good API design. Though there are things that can and should be controlled in the frontend, things like these should really be decided directly in the backend. With this comes a balancing act in API design to make sure the clients have the right tools to accomplish what they need to do, while still supporting various use cases without affecting long-term maintainability.

### Taking it back to RPC

In the days of [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call), clients would call functions on the backend that did exactly what they needed to do. This resulted in a somewhat "client-first" approach, where these functions would be tailor-made to support the client's functionality. For example, in this case you could imagine having an endpoint `/updateDestinationAndTrackGroup` that takes inputs as-is, which means we can have all these things correctly decided on the backend through a single request.

Obviously this _also_ means that the client and server end up being tightly coupled, which introduces a whole other set of issues. In addition, it can be easy to end up with tons of similar functions to support slightly different use cases, which can be hard to maintain.

### Let's REST

The more common [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) approach used today leads to building more general APIs to support a wide range of use cases with the same interface. This means that your frontend and backend can evolve independently as long as that contract is maintained. However, it's still important to keep in mind how the consumers of the API are going to use it and what those requirements are when designing the API.

Many times I've seen so-called "RESTful" APIs expose actions as additional endpoints for a resource. For example, in the context of syncing data you could imagine calling `POST` on an endpoint `/destination/hubspot/export` to trigger an action that exports all profiles to the destination.

This approach is quite common, but as it turns out, it's not _technically_ REST and is actually more RPC-like. With that said, though REST purists may frown upon it, I think it's an okay pattern to follow in certain cases where there really isn't a resource to represent certain actions. Of course, it's important to keep in mind how many of these actions you're creating and if they really can't be better expressed as resources.

In our case, we were able to just add an additional property to the destination's `PUT` request, `trackedGroupId`, and move all the logic that determines whether profiles should be updated or not to the backend. This allowed us to make a single API request from the client that would decide and execute the necessary side-effects that had to take place.

---

In summary, **keep the clients in mind**. No matter what style of API you're building, it's important to think about how consumers may need to interact with it and use this to inform its design. Watch out for instances where the client needs to deal with complex logic and identify if this is really something that could be more appropriately addressed directly in the API.

At Grouparoo we deal with lots of APIs to [integrate](/integrations) with third-party systems, and we've seen our fair share of excellent and not-so-great APIs. It's always great when integrating with a platform that has thought through these use cases and exposes an API that's easy to work with.
