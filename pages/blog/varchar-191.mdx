---
title: "Why do database columns have a character length of 191?"
date: "2021-05-14"
author: "Evan Tahler"
pullQuote: "`varchar(191)` is such an odd number - how did we get here?"
image: "varchar-191/210515-varchar191.png"
tags: [engineering, notes]
---

<Image
  centered
  alt="A Database symbol over a library"
  src="varchar-191/210515-varchar191.png"
  width={1015}
  height={533}
/>

Sometimes, when you are looking at a database‚Äôs schema, you see that there are text fields defined like `email_address varchar(191) NOT NULL` - meaning that the column supports strings with a maximum length of 191 characters, and can‚Äôt be `null`. 191 is such an odd number - where did it come from? In this post, we‚Äôll look at the historical reasons for the 191 character limit.

## Why `varchar` and not `text`?

The first question you might ask is why limit the length of the strings you can store in a database at all? All popular relational database support (almost) unlimited size strings with a `text` or `blob` -type column, so why not use that? The reason is **indexes**.

If you are going to search by this column, say `email_address`, you probably want to add an index to it to speed things up when you `select id from users where email = 'foo@example.com'` . As your table gets bigger, searches get slower as your database has to check every row to find the user who has the email address `foo@example.com`. However, if you add a search index, you are telling your database to essentially ‚Äúpre-compute‚Äù popular search patterns with a tree so the next search is much faster. In essence, indexes cost pre-computation (and a little bit of disk space) making writes to the database slower, to speed up reads later. For most applications, this is a great tradeoff, since they are "read heavy" and "write lite".

So, why use `varchar`? Indexes preform better when assumptions can be made about the type of data in the index, and knowing how long the strings in the index are is a huge help. For some database, you aren‚Äôt allowed to add a search index to columns of type `text`, while in others, the index just won‚Äôt preform as well. In fact, historically, databases were created with limits to how big an index could be to optimize how fast they could search, and how they stored data on disk.

## It‚Äôs MySQL‚Äôs fault

Ok, so indexes are good. But, generically, it seems that an index of _any_ size should work, and that‚Äôs true today. The next stop on our journey is to look at what the default column size was far in the past, and that was 255 characters, e.g.: `email_address varchar(255) NOT NULL`.

256 is a power of 2, so it shows up often computer science. In this case, MySQL, the most popular open source database of the early 2000‚Äôs, had a strong default for 255 characters, because it was itself emulating functionality for even older databases which had a memory limit (or disk limit) of 256 bytes per column [[CITATION NEEDED]]. With that compatibility in mind, MySQL went further to optimize many parts of itself against a 255 character limit (more on this later).

Since many popular open source application frameworks launched in that time period (Wordpress, Django, and Rails to name a few), they all followed mySQL‚Äôs defaults, even when they could run on multiple database types (eg: postgres). This formed a common default for most ORMs ([Object‚Äìrelational mapping - Wikipedia](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)) to use `varchar(255)` as a default, no matter the database in use.

## It‚Äôs üêü‚Äôs fault

255 makes a lot more sense than 191. How did we get to 191? I‚Äôm going to blame emoji üòú. Seriously. Well, `utf8mb4` at least, the charter set that allows for "international" [^1] letters, and included the first emoji. MySQL in the early 2000‚Äôs was happy supporting 255 characters in `varchar` columns and indexing them. However, the the most popular text encoding (`Latin1` or `utf8` ) on the most popular MySQL database engine (`innodb`) assumed that 3 bytes was enough to store every character [^2], and once `utf8mb4` came along with characters like †º≠ and üêü, 4 bytes were needed to store each character.

The way `innodb` MySQL databases worked was that you can only have 767 bytes for an index - enough to store 255 3-byte characters (`767/3 = 255`). This is an extreme example of index optimization where knowing the size of the data you are indexing matters! So if the characters took more space to store, then the number of characters you could index had to get smaller. Specifically, `767/4 = 191` characters! As more software supported an international audience, `varchar(191)` replaced `varchar(255)` as the default.

[^1]: "International" is an odd way to talk about the languages that most of the world uses, specifically non-latin asian characters. However, operating systems and databases had painfully english-centric origins, and the legacy of those early choices is still rippling though our code today.
[^2]: Throughout this post, I've use the word "character" rather than letter, and this is why - depending on your language, each character in a string might be a letter, a whole word, or even a pictogram like an emoji.

## Today

These days, with modern databases, character encodings like `utf8mb4` and others which can support "all" characters are the default, and the fixed-length index is a thing of the past, but we still have these defaults. Indexes still work best when they know the size of the the strings they are comparing, so we still want to have _some_ limit on our column length for speed reasons, and thanks to history and inertia, the 191 is still with us.

## Thank you

Thanks to all the reference articles I checked when putting together this history:

- [mysql - Wordpress using varchar(255) for index with InnoDB and utf8mb4_unicode_ci? - Database Administrators Stack Exchange](https://dba.stackexchange.com/questions/141149/wordpress-using-varchar255-for-index-with-innodb-and-utf8mb4-unicode-ci)
- [Why do some fields have a varchar precision of 191 for modUserProfile in the modx schema? - #4 by jeffmiranda - Development - MODX Community](https://community.modx.com/t/why-do-some-fields-have-a-varchar-precision-of-191-for-moduserprofile-in-the-modx-schema/940/4)
- [utf 8 - Mysql four byte chinese characters support - Stack Overflow](https://stackoverflow.com/questions/17680237/mysql-four-byte-chinese-characters-support)
- [Varchar fields on MySQL 5.7 ‚Äì gabi.dev](https://gabi.dev/2016/09/08/varchar-fields-on-mysql-5-7/)
