---
title: "Deferring Side-Effects in Node.js until the End of a Transaction"
date: "2021-01-21"
author: "Evan Tahler"
pullQuote: "Using AsyncHooks, you can collect side-effects within a database transaction and only run them if the transaction succeeds"
image: "defering-side-effects-in-node/filiberto-santillan-HeyFNqApSLQ-unsplash.jpg"
tags: [engineering]
---

<Image
  centered
  alt="Steps of a simple sync"
  src="defering-side-effects-in-node/filiberto-santillan-HeyFNqApSLQ-unsplash.jpg"
  width={1000}
  height={667}
/>

At Grouparoo, we use [Actionhero](https://www.actionherojs.com) as our Node.js API server, and [Sequelize](https://sequelize.org) for our Object Relational Mapping (ORM) - making it easy to work with complex records from our database. Within our Actions and Tasks, we often want to treat the whole execution as a singe [database transaction](https://stackoverflow.com/questions/974596/what-is-a-database-transaction) - either all the modifications to the database will succeed or fail as a unit. This is really helpful when a single activity may create or modify a number of database rows.

## Why do we need Transactions?

Take the following example from a prototypical blogging site. When a user is created (`POST /api/v1/user`), we also create their first post and send them a welcome Email.

```ts
import { action } from "actionhero"
import { User, Post } from "../models"

export class UserCreate extends Action {
  constructor() {
    super();
    this.name = "user:create";
    this.description = "create a user and thier first post";
    this.inputs = {
      firstName: { required: true },
      lastName: { required: true },
      password: { required: true },
      email: { required: true },
    };
  }

  async run({ params }) {
    const user = await User.create(params);
    await user.updatePassword(params.password);
    await user.sendWelcomeEmail();

    const post = await new Post({
      userId: user.id,
      title: 'My First Post',
      published: false.
    })

    return { userId: user.id, postId: post.id };
  }
}
```

In this example, we:

1. Create the user record
2. Update the user’s password
3. Send the welcome email
4. Create the first post for the new user
5. Return the IDs of the new records created

This works as long as nothing fails mid-action. What if we couldn’t update the user’s password? The new User record would still be in our database, and we would need a try/catch to clean up the data. If not, when the user tries to sign up again, they couldn’t as there would already be an account for their email address.

To solve, this you could use transactions. Using [Sequelize’s Managed Transactions](https://sequelize.org/master/manual/transactions.html), this would change the run method of the Action to be:

```ts
async run({ params }) {
  return sequelize.transaction(async (t) => {
    const user = await User.create(params, {transaction: t});
    await user.updatePassword(params.password, {transaction: t} );
    await user.sendWelcomeEmail();

    const post = await new Post({
      userId: user.id,
      title: 'My First Post',
      published: false.
    }, {transaction: t})

    return { userId: user.id, postId: post.id };
  })
}
```

Managed Transactions in Sequelize are very helpful - you don’t need to worry about rolling back the transaction if something goes wrong. If there’s an error `throw`n, it will rollback the whole transaction automatically.

While this is safer than the first attempt, there are still some problems:

1. We have to remember to pass the `transaction` object to every Sequelize call
2. We need to ensure that every method we call which _could_ read or write to the database needs to use the transaction as well, and take it as an argument (like `user.updatePassword()`)
3. Sending the welcome email is not transaction safe.

Sending the email here will happen even if we roll back the whole transaction because of an error creating the new post… which isn’t great if the user record wasn’t committed! So what do we do?

## Automatically Pass Transactions to all Queries: CLS-Hooked

The solution to our problem comes from a wonderful package called [`cls-hooked`](https://github.com/Jeff-Lewis/cls-hooked). Using the magic of [`AsyncHooks`](https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md), this package can tell when certain code is _within_ a callback chain or promise. In this way, you can say roughly: "for all methods invoked within this async function, I want to keep this variable in scope". This is pretty wild! If you opt into using Sequelzie with CLS-Hooked, _every_ SQL statement will check to see if there is already a transaction in scope. There’s a performance penalty for doing this, but in our testing, it isn’t noticeable compared to `await`ing SQL results from a remote database., however your milage may vary.

This means that our run method now can look like:

```ts
// Elsewhere in the Project

const cls = require('cls-hooked');
const namespace = cls.createNamespace('actionhero')
const Sequelize = require('sequelize');
Sequelize.useCLS(namespace);
new Sequelize(....);

// Our Run Method

async run({ params }) {
  return sequelize.transaction(async (t) => {
    const user = await User.create(params);
    await user.updatePassword(params.password);
    await user.sendWelcomeEmail();

    const post = await new Post({
      userId: user.id,
      title: 'My First Post',
      published: false.
    })

    return { userId: user.id, postId: post.id };
  })
}
```

Ok! We’s solved the need of passing transactions to all queries and sub-methods! All that remains now is the `user.sendWelcomeEmail()` side-effect. How can we delay this method until the end of the transaction?

## CLS and Deferred Execution

Looking deeper into how `cls-hooked` works, we can see that it is possible to tell if you are in a namespace currently, and to set and get values from the namespace. Think of this like a session… but for the callback or promise your code is within!

With this in mind, we can write our run method to be **transaction-aware**. This means that we can use a pattern that knows to run a function in-line if we aren’t within a transaction, but if we are, defer it until the end. We’ve wrapped utilities to do this within [Grouparoo’s CLS module](https://github.com/grouparoo/grouparoo/blob/master/core/src/modules/cls.ts).

With the CLS modules you can write code like this:

```ts
// from the Grouparoo Test Suite: Within Transaction

test("in a transaction, deferred jobs will be run afterwords", async () => {
  const results = [];
  const runner = async () => {
    await CLS.afterCommit(() => results.push("side-effect-1"));
    await CLS.afterCommit(() => results.push("side-effect-2"));
    results.push("in-line");
  };

  await CLS.wrap(() => runner());
  expect(results).toEqual(["in-line", "side-effect-1", "side-effect-2"]);
});
```

You can see here that once you `CLS.wrap()` an `async` function, you can defer the execution of anything wrapped with `CLS.afterCommit()` until the transaction is complete.

You can also take the same code and not apply `CLS.wrap()` to it to see that it still works, but the order of the side-effects has changed:

```ts
// from the Grouparoo Test Suite: Without Transaction

test("without a transaction, deferred jobs will be run in-line", async () => {
  const results = [];
  const runner = async () => {
    await CLS.afterCommit(() => results.push("side-effect-1"));
    await CLS.afterCommit(() => results.push("side-effect-2"));
    results.push("in-line");
  };

  await runner();
  expect(results).toEqual(["side-effect-1", "side-effect-2", "in-line"]);
});
```

## CLSAction and CLSTask

Now that we can take arbitrary functions and delay their execution until the transaction is complete, we can use these techniques to make a new type of Action and Task that has this built in. We call these [`CLSAction`](https://github.com/grouparoo/grouparoo/blob/master/core/src/classes/actions/clsAction.ts) and [`CLSTask`](https://github.com/grouparoo/grouparoo/blob/master/core/src/classes/tasks/clsTask.ts). These new classes extend the regular Actionhero Actions and Tasks, but provide a new `runWithinTransaction` method to replace `run`, which helpfully already uses `CLS.wrap()`. This makes it easy for us to opt-into an Action in which automatically runs within a Sequelize transaction, and can handle deferred side-effects!

Putting everything together, our new transaction-safe Action looks like this:

```ts
import { Action } from "actionhero";
import { CLS } from "../modules/cls";
import { User, Post } from "../models";

// *** Define the CLSAction Class ***

export abstract class CLSAction extends Action {
  constructor() {
    super();
  }

  async run(data) {
    return CLS.wrap(async () => await this.runWithinTransaction(data));
  }

  abstract runWithinTransaction(data): Promise<any>;
}

// *** Use the CLSAction Class ***

export class UserCreate extends CLSAction {
  constructor() {
    super();
    this.name = "user:create";
    this.description = "create a user and thier first post";
    this.inputs = {
      firstName: { required: true },
      lastName: { required: true },
      password: { required: true },
      email: { required: true },
    };
  }

  // runWithinTransaction automatically applies transactions to all Seqeulzie methods/models
  async runWithinTransaction({ params }) {
    const user = await User.create(params);
    await user.updatePassword(params.password);

    // the email will be sent only if the transaction succeeds
    await CLS.afterCommit(user.sendWelcomeEmail);

    const post = await new Post({
      userId: user.id,
      title: 'My First Post',
      published: false.
    })

    return { userId: user.id, postId: post.id };
  }
}
```

If the transaction fails, the email won’t be sent, and all the models will not be committed.

## Summary

The `cls-hooked` module is a very powerful tool. If used globally, it unlocks the ability to produce side-effects throughout your application worry-free. Perhaps your models need to enqueue a Task every time they are created… now you can as long as you `cls.wrap()` it. You can be sure that task won’t be enqueued unless the model was really saved and committed.
